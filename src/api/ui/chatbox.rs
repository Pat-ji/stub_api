static EMPTY_VEC_I8 : Vec < i8 > = vec ! [] ; static EMPTY_VEC_I32 : Vec < i32 > = vec ! [] ; use crate :: api :: client :: { _client_get_chat_buffers , client_get_current_time } ; use crate :: api :: domain :: chat_message :: RSChatMessage ; use crate :: api :: domain :: widget :: RSWidget ; use crate :: api :: input :: keyboard :: keyboard_type_string ; use crate :: api :: ui :: widgets :: widgets_get_widget ; use crate :: api :: util :: utils :: { utils_sleep , utils_sleep_conditional } ; use crate :: c_address :: CAddress ; use crate :: offsets ; use strum_macros :: EnumIter ; pub (crate) const CHATBOX_CONTAINER_WIDGET_ID : i32 = 162 ; const CHATBOX_CONTAINER_WIDGET_CHILD_ID : i32 = 35 ; const CHATBOX_INPUT_WIDGET_CHILD_ID : i32 = 43 ; fn chatbox_get_container_widget () -> Option < RSWidget > { unimplemented ! () } pub fn chatbox_get_input_widget () -> Option < RSWidget > { unimplemented ! () } pub fn chatbox_is_visible () -> bool { unimplemented ! () } pub fn chatbox_is_select_input_visible () -> bool { unimplemented ! () } pub fn chatbox_enter_amount (amount : i32) -> bool { unimplemented ! () } pub fn chatbox_enter_input (input : & str) -> bool { unimplemented ! () } fn chatbox_get_chat_buffer (chat_message_type : & ChatMessageType) -> Option < CAddress > { unimplemented ! () } pub fn chatbox_get_messages_after_timestamp (chat_message_type : & ChatMessageType , timestamp : i32) -> impl Iterator < Item = RSChatMessage > { std :: iter :: empty () } pub fn chatbox_get_messages (chat_message_type : & ChatMessageType) -> impl Iterator < Item = RSChatMessage > { std :: iter :: empty () } pub fn chatbox_get_last_message (chat_message_type : & ChatMessageType) -> Option < RSChatMessage > { unimplemented ! () } pub struct ChatMessagePoller { chat_message_type : ChatMessageType , last_timestamp : i32 } impl ChatMessagePoller { pub fn new (chat_message_type : ChatMessageType) -> Self { unimplemented ! () } pub fn get_chat_message_type (& self) -> & ChatMessageType { unimplemented ! () } pub fn poll (& mut self) -> impl Iterator < Item = RSChatMessage > + use < '_ > { std :: iter :: empty () } } pub trait ChatMessageListener : { fn on_chat_message (& mut self , chat_message_type : ChatMessageType , chat_message : & RSChatMessage) ; } # [repr (C)] # [derive (EnumIter , PartialEq , Clone , Copy , Debug)] pub enum ChatMessageType { Game = 0 , Modchat = 1 , Publicchat = 2 , Privatechat = 3 , Engine = 4 , LoginLogoutNotification = 5 , PrivatechatOut = 6 , ModPrivateChat = 7 , FriendsChat = 9 , FriendsChatNotification = 11 , TradeSent = 12 , Broadcast = 14 , SnapshotFeedback = 26 , ItemExamine = 27 , NpcExamine = 28 , ObjectExamine = 29 , FriendNotification = 30 , IgnoreNotification = 31 , ClanChat = 41 , ClanMessage = 43 , ClanGuestChat = 44 , ClanGuestMessage = 46 , AutoTyper = 90 , ModAutoTyper = 91 , Console = 99 , TradeReq = 101 , Trade = 102 , ChalReqTrade = 103 , ChalReqFriendsChat = 104 , Spam = 105 , PlayerRelated = 106 , TenSecTimeout = 107 , Welcome = 108 , ClanCreationInvitation = 109 , ChalReqClanChat = 110 , ClanGimFormGroup = 111 , ClanGimGroupWith = 112 , Dialog = 114 , Mesbox = 115 , NpcSay = 116 , Unknown = - 1 , } impl ChatMessageType { fn get_type (self) -> i32 { unimplemented ! () } } pub enum ChatboxTab { All , Private , Public , Game , Channel , Clan , TradeGroup , } impl ChatboxTab { fn get_message_types (& self) -> & [ChatMessageType] { unimplemented ! () } }