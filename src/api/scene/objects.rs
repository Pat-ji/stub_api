static EMPTY_VEC_I8 : Vec < i8 > = vec ! [] ; static EMPTY_VEC_I32 : Vec < i32 > = vec ! [] ; use crate :: api :: domain :: entity :: Entity ; use crate :: api :: domain :: ground_decoration :: RSGroundDecoration ; use crate :: api :: domain :: interactable_object :: RSInteractableObject ; use crate :: api :: domain :: object :: { Object , TileObjects } ; use crate :: api :: domain :: wall_decoration :: RSWallDecoration ; use crate :: api :: domain :: wall_object :: RSWallObject ; use crate :: api :: domain :: world_view :: RSWorldView ; use crate :: api :: scene :: coords :: position :: Position ; use crate :: api :: scene :: entities :: ENTITIES_TYPE_OBJECT ; use crate :: api :: scene :: players :: players_get_local_player ; use crate :: api :: scene :: world_view :: world_view_get_world_view ; use crate :: api :: util :: find_args :: { IdArgs , NameArgs } ; use crate :: api :: util :: performance :: PERFORMANCE_MAX_OBJECTS_RANGE ; use crate :: c_address :: CAddress ; use crate :: offsets ; pub const OBJECTS_GROUND_DECORATION_FLAG : i32 = 1 << 0 ; pub const OBJECTS_WALL_DECORATION_FLAG : i32 = 1 << 1 ; pub const OBJECTS_WALL_OBJECT_FLAG : i32 = 1 << 2 ; pub const OBJECTS_INTERACTABLE_OBJECT_FLAG : i32 = 1 << 3 ; pub const OBJECTS_ALL_OBJECTS_FLAG : i32 = OBJECTS_GROUND_DECORATION_FLAG | OBJECTS_WALL_DECORATION_FLAG | OBJECTS_WALL_OBJECT_FLAG | OBJECTS_INTERACTABLE_OBJECT_FLAG ; pub fn objects_find_closest_by_id < T : Into < IdArgs > > (flags : i32 , args : T) -> Option < Box < dyn Object > > { unimplemented ! () } # [macro_export] macro_rules ! objects_find_closest_by_id { ($ predicate : expr) => { objects_find_closest_by_id (OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; } pub fn objects_find_closest_by_name < T : Into < NameArgs > > (flags : i32 , args : T) -> Option < Box < dyn Object > > { unimplemented ! () } # [macro_export] macro_rules ! objects_find_closest_by_name { ($ predicate : expr) => { objects_find_closest_by_name (OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; } pub fn objects_find_closest_conditional (flags : i32 , predicate : impl Fn (& dyn Object) -> bool) -> Option < Box < dyn Object > > { unimplemented ! () } # [macro_export] macro_rules ! objects_find_closest_conditional { ($ predicate : expr) => { objects_find_closest_conditional (OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; } pub fn objects_find_closest_to_by_id < T : Into < IdArgs > > (to : Position , flags : i32 , args : T) -> Option < Box < dyn Object > > { unimplemented ! () } # [macro_export] macro_rules ! objects_find_closest_to_by_id { ($ to : expr , $ predicate : expr) => { objects_find_closest_to_by_id ($ to , OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; } pub fn objects_find_closest_to_by_name < T : Into < NameArgs > > (to : Position , flags : i32 , args : T) -> Option < Box < dyn Object > > { unimplemented ! () } # [macro_export] macro_rules ! objects_find_closest_to_by_name { ($ to : expr , $ predicate : expr) => { objects_find_closest_to_by_name ($ to , OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; } pub fn objects_find_closest_to_conditional (to : Position , flags : i32 , predicate : impl Fn (& dyn Object) -> bool) -> Option < Box < dyn Object > > { unimplemented ! () } # [macro_export] macro_rules ! objects_find_closest_to_conditional { ($ to : expr , $ predicate : expr) => { objects_find_closest_to_conditional ($ to , OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; } pub fn objects_find_by_id < T : Into < IdArgs > > (plane : i32 , flags : i32 , args : T) -> Option < Box < dyn Object > > { unimplemented ! () } # [macro_export] macro_rules ! objects_find_by_id { ($ plane : expr , $ args : expr) => { objects_find_by_id ($ plane , OBJECTS_ALL_OBJECTS_FLAG , $ args) } ; ($ args : expr) => { objects_find_by_id (world_view_get_plane () , OBJECTS_ALL_OBJECTS_FLAG , $ args) } ; } pub fn objects_find_by_name < T : Into < NameArgs > > (plane : i32 , flags : i32 , args : T) -> Option < Box < dyn Object > > { unimplemented ! () } # [macro_export] macro_rules ! objects_find_by_name { ($ plane : expr , $ args : expr) => { objects_find_by_name ($ plane , OBJECTS_ALL_OBJECTS_FLAG , $ args) } ; ($ args : expr) => { objects_find_by_name (world_view_get_plane () , OBJECTS_ALL_OBJECTS_FLAG , $ args) } ; } pub fn objects_find_all_by_id < T : Into < IdArgs > > (plane : i32 , flags : i32 , args : T) -> Vec < Box < dyn Object > > { Vec :: new () } # [macro_export] macro_rules ! objects_find_all_by_id { ($ plane : expr , $ args : expr) => { objects_find_all_by_id ($ plane , OBJECTS_ALL_OBJECTS_FLAG , $ args) } ; ($ args : expr) => { objects_find_all_by_id (world_view_get_plane () , OBJECTS_ALL_OBJECTS_FLAG , $ args) } ; } pub fn objects_find_all_by_name < T : Into < NameArgs > > (plane : i32 , flags : i32 , args : T) -> Vec < Box < dyn Object > > { Vec :: new () } # [macro_export] macro_rules ! objects_find_all_by_name { ($ plane : expr , $ args : expr) => { objects_find_all_by_name ($ plane , OBJECTS_ALL_OBJECTS_FLAG , $ args) } ; ($ args : expr) => { objects_find_all_by_name (world_view_get_plane () , OBJECTS_ALL_OBJECTS_FLAG , $ args) } ; } pub fn objects_find_at_position_conditional (position : & Position , flags : i32 , predicate : impl Fn (& dyn Object) -> bool) -> Option < Box < dyn Object > > { unimplemented ! () } pub fn objects_find_at_conditional (x : i32 , y : i32 , plane : i32 , flags : i32 , predicate : impl Fn (& dyn Object) -> bool) -> Option < Box < dyn Object > > { unimplemented ! () } pub fn objects_find_at_local_conditional (local_x : i32 , local_y : i32 , plane : i32 , flags : i32 , predicate : impl Fn (& dyn Object) -> bool) -> Option < Box < dyn Object > > { unimplemented ! () } pub fn objects_find_conditional (plane : i32 , flags : i32 , predicate : impl Fn (& dyn Object) -> bool) -> Option < Box < dyn Object > > { unimplemented ! () } # [macro_export] macro_rules ! objects_find_conditional { ($ plane : expr , $ predicate : expr) => { objects_find_conditional ($ plane , OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; ($ predicate : expr) => { objects_find_conditional (world_view_get_plane () , OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; } pub fn objects_find_all_conditional (plane : i32 , flags : i32 , predicate : impl Fn (& dyn Object) -> bool) -> Vec < Box < dyn Object > > { Vec :: new () } # [macro_export] macro_rules ! objects_find_all_conditional { ($ plane : expr , $ predicate : expr) => { objects_find_all_conditional ($ plane , OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; ($ predicate : expr) => { objects_find_all_conditional (world_view_get_plane () , OBJECTS_ALL_OBJECTS_FLAG , $ predicate) } ; } pub fn objects_get_at_local (local_x : i32 , local_y : i32 , plane : i32 , flags : i32) -> TileObjects { unimplemented ! () } # [macro_export] macro_rules ! objects_get_at_local { ($ local_x : expr , $ local_y : expr , $ plane : expr) => { objects_get_at_local ($ local_x , $ local_y , $ plane , OBJECTS_ALL_OBJECTS_FLAG) } } pub fn objects_get_at (x : i32 , y : i32 , plane : i32 , flags : i32) -> TileObjects { unimplemented ! () } # [macro_export] macro_rules ! objects_get_at { ($ x : expr , $ y : expr , $ plane : expr) => { objects_get_at ($ x , $ y , $ plane , OBJECTS_ALL_OBJECTS_FLAG) } } pub fn objects_get_all (plane : i32 , flags : i32) -> impl Iterator < Item = TileObjects > { std :: iter :: empty () } # [macro_export] macro_rules ! objects_get_all { ($ plane : expr) => { objects_get_all ($ plane , OBJECTS_ALL_OBJECTS_FLAG) } ; () => { objects_get_all (world_view_get_plane () , OBJECTS_ALL_OBJECTS_FLAG) } ; } fn objects_check_tile_objects_conditional (tile_objects : & TileObjects , predicate : & impl Fn (& dyn Object) -> bool) -> Option < Box < dyn Object > > { unimplemented ! () } fn objects_get_tile_objects (tile : CAddress , world_view : RSWorldView , flags : i32) -> TileObjects { unimplemented ! () } fn objects_closest (position : Position , objects : Vec < Box < dyn Object > >) -> Option < Box < dyn Object > > { unimplemented ! () }