static EMPTY_VEC_I8 : Vec < i8 > = vec ! [] ; static EMPTY_VEC_I32 : Vec < i32 > = vec ! [] ; use crate :: api :: domain :: entity :: Entity ; use crate :: api :: domain :: object :: Object ; use crate :: api :: domain :: world_view :: RSWorldView ; use crate :: api :: scene :: coords :: position :: Position ; use crate :: api :: scene :: map :: MAP_GET_SIZE ; use crate :: api :: scene :: players :: players_get_local_player ; use crate :: api :: scene :: world_view :: world_view_get_world_view ; use std :: cmp :: { Ordering , Reverse } ; use std :: collections :: BinaryHeap ; use std :: mem :: MaybeUninit ; pub (crate) const DIRECTIONS : [(i32 , i32 , u32 , i32) ; 4] = [(- 1 , 0 , 2 , 19661064) , (1 , 0 , 8 , 19661184) , (0 , - 1 , 1 , 19661058) , (0 , 1 , 4 , 19661088) ,] ; pub fn local_path_finder_find_to_object (object : & Box < dyn Object > , flags : & [[i32 ; MAP_GET_SIZE] ; MAP_GET_SIZE]) -> Option < Vec < Position > > { None } pub fn local_path_finder_find_position_to_object (from : & Position , object : & Box < dyn Object > , flags : & [[i32 ; MAP_GET_SIZE] ; MAP_GET_SIZE]) -> Option < Vec < Position > > { None } pub fn local_path_finder_find_to_position (position : & Position , flags : & [[i32 ; MAP_GET_SIZE] ; MAP_GET_SIZE]) -> Option < Vec < Position > > { None } pub fn local_path_finder_find_position_to_position (start : & Position , end : & Position , flags : & [[i32 ; MAP_GET_SIZE] ; MAP_GET_SIZE]) -> Option < Vec < Position > > { None } pub fn local_path_finder_find_path (src_x : i32 , src_y : i32 , dst_x : i32 , dst_y : i32 , object_type : i32 , orientation : i32 , size_x : i32 , size_y : i32 , walk_to_data : u32 , flags : & [[i32 ; MAP_GET_SIZE] ; MAP_GET_SIZE]) -> Option < Vec < Position > > { None } # [derive (Debug , Clone , Copy , PartialEq , Eq)] struct TileNode { cost : i32 , f_score : i32 , x : i32 , y : i32 , via : u32 , clipping : i32 , flags : u8 , } impl TileNode { fn new (x : i32 , y : i32 , clipping : i32) -> Self { unimplemented ! () } fn is_open (& self) -> bool { unimplemented ! () } fn set_open (& mut self , val : bool) { { } } fn is_closed (& self) -> bool { unimplemented ! () } fn set_closed (& mut self , val : bool) { { } } } impl Ord for TileNode { fn cmp (& self , other : & Self) -> Ordering { unimplemented ! () } } impl PartialOrd for TileNode { fn partial_cmp (& self , other : & Self) -> Option < Ordering > { unimplemented ! () } } # [derive (Debug)] struct TileNodeMap { nodes : Box < [[TileNode ; MAP_GET_SIZE] ; MAP_GET_SIZE] > } impl TileNodeMap { pub (crate) fn new (flags : & [[i32 ; MAP_GET_SIZE] ; MAP_GET_SIZE]) -> Self { unimplemented ! () } fn get_node (& mut self , x : i32 , y : i32) -> & mut TileNode { unimplemented ! () } } fn heuristic (x1 : i32 , y1 : i32 , x2 : i32 , y2 : i32) -> i32 { unimplemented ! () } fn reached_object (dst_x : i32 , dst_y : i32 , cur_x : i32 , cur_y : i32 , object_type : i32 , direction : i32 , node_map : & mut TileNodeMap) -> bool { unimplemented ! () } fn reached_object_2 (dst_x : i32 , dst_y : i32 , cur_x : i32 , cur_y : i32 , object_type : i32 , mut direction : i32 , node_map : & mut TileNodeMap) -> bool { unimplemented ! () } fn reached_object_3 (dst_x : i32 , dst_y : i32 , cur_x : i32 , cur_y : i32 , size_x : i32 , size_y : i32 , walk_to_data : u32 , node_map : & mut TileNodeMap) -> bool { unimplemented ! () }