static EMPTY_VEC_I8 : Vec < i8 > = vec ! [] ; static EMPTY_VEC_I32 : Vec < i32 > = vec ! [] ; use crate :: api :: scene :: coords :: position :: Position ; use crate :: api :: scene :: webwalker :: web_player_profile :: WebPlayerProfile ; use crate :: api :: ui :: bank :: bank_close ; use crate :: api :: ui :: chatbox :: { chatbox_get_last_message , ChatMessageType } ; use crate :: api :: ui :: dialogue :: { dialogue_complete_dialogue , dialogue_is_in_dialogue } ; use crate :: api :: ui :: store :: store_close ; use crate :: api :: ui :: tab :: diaries :: Diary ; use crate :: api :: ui :: tab :: equipment :: equipment_find_by_name_contains ; use crate :: api :: ui :: tab :: inventory :: { inventory_find_by_name_contains , inventory_interact_by_name } ; use crate :: api :: ui :: tab :: magic :: { magic_cast_spell_action , ArceuusSpells , LunarSpells , MagicSpell , NormalSpells , Rune , Staves } ; use crate :: api :: ui :: tab :: quests :: Quest ; use crate :: api :: ui :: tab :: skills :: Skill ; use crate :: api :: ui :: tab :: tabs :: { tabs_open_tab , Tab } ; use crate :: api :: util :: utils :: utils_sleep_conditional ; use strum :: IntoEnumIterator ; use strum_macros :: EnumIter ; pub (crate) struct WebTeleport { destination : Position , condition : Box < dyn Fn (& WebPlayerProfile) -> bool + 'static > , script : Box < dyn Fn () -> bool + 'static > , } impl WebTeleport { pub (crate) fn new < F1 , F2 > (destination : Position , condition : F1 , script : F2) -> Self { unimplemented ! () } pub (crate) fn get_destination (& self) -> & Position { unimplemented ! () } pub (crate) fn check_condition (& self , profile : & WebPlayerProfile) -> bool { unimplemented ! () } pub (crate) fn execute_script (& self) -> bool { unimplemented ! () } } pub (crate) fn web_teleport_get_all () -> Vec < WebTeleport > { Vec :: new () } fn spell_simple < T : MagicSpell + Clone + 'static + Copy > (spell : & T , destination : Position , runes : & [RuneElementAndAmount] , result : & mut Vec < WebTeleport > ,) { { } } fn spell_conditional < T : MagicSpell + Copy + Clone + 'static , F : Fn (& WebPlayerProfile) -> bool + Send + Sync + 'static > (spell : & T , destination : Position , condition : F , runes : & [RuneElementAndAmount] , result : & mut Vec < WebTeleport > ,) { { } } fn teleport_spell < T : MagicSpell + Copy + Clone + 'static , F : Fn (& WebPlayerProfile) -> bool + 'static > (spell : T , action : & 'static str , destination : Position , condition : F , runes : & [RuneElementAndAmount] , result : & mut Vec < WebTeleport > ,) { { } } fn telescroll < F : Fn (& WebPlayerProfile) -> bool + 'static > (item_name : & 'static str , destination : Position , condition : F , result : & mut Vec < WebTeleport >) { { } } fn teletab < F : Fn (& WebPlayerProfile) -> bool + 'static > (item_name : & 'static str , destination : Position , condition : F , result : & mut Vec < WebTeleport >) { { } } fn wearable_simple < F : Fn (& WebPlayerProfile) -> bool + 'static > (item_name : & 'static str , action : & 'static str , destination : Position , condition : F , result : & mut Vec < WebTeleport >) { { } } fn wearable < F : Fn (& WebPlayerProfile) -> bool + 'static > (item_name : & 'static str , action : & 'static str , destination : Position , members : bool , contains_name : bool , condition : F , result : & mut Vec < WebTeleport >) { { } } fn wearable_multi_action < F : Fn (& WebPlayerProfile) -> bool + 'static > (item_name : & 'static str , inventory_action : & 'static str , equipment_action : & 'static str , destination : Position , condition : F , result : & mut Vec < WebTeleport >) { { } } fn ectophial (result : & mut Vec < WebTeleport >) { { } } fn teleport_inventory_equipment < F : Fn (& WebPlayerProfile) -> bool + 'static > (item_name : & 'static str , inventory_action : & 'static str , equipment_action : & 'static str , destination : Position , members : bool , contains_name : bool , condition : F , result : & mut Vec < WebTeleport >) { { } } fn teleport_inventory < F : Fn (& WebPlayerProfile) -> bool + 'static > (item_name : & 'static str , action : & 'static str , destination : Position , members : bool , contains_name : bool , condition : F , result : & mut Vec < WebTeleport >) { { } } # [derive (Debug , Clone , PartialEq , EnumIter)] enum RuneElement { Air , Water , Fire , Earth , Mind , Law , Soul , Nature , Astral , } impl RuneElement { fn get_runes (& self) -> & [Rune] { unimplemented ! () } fn get_rune_amount (& self , player_profile : & WebPlayerProfile) -> i64 { unimplemented ! () } } # [derive (Clone)] struct RuneElementAndAmount { rune_element : RuneElement , amount : i32 , } impl RuneElementAndAmount { fn new (rune_element : RuneElement , amount : i32) -> Self { unimplemented ! () } fn has_all_runes (& self , player_profile : & WebPlayerProfile) -> bool { unimplemented ! () } } impl Rune { fn get_pouch_index (& self) -> i32 { unimplemented ! () } fn get_usable_amount (& self , player_profile : & WebPlayerProfile) -> i64 { unimplemented ! () } fn has_rune_tome_equipped (& self , player_profile : & WebPlayerProfile) -> bool { unimplemented ! () } } impl Staves { fn has_rune_equipped (& self , rune : & Rune , player_profile : & WebPlayerProfile) -> bool { unimplemented ! () } } # [derive (Debug , PartialEq , EnumIter)] enum RunePouch { First , Second , Third , Fourth , } impl RunePouch { fn get_rune_varp (& self) -> i32 { unimplemented ! () } fn get_rune_shift (& self) -> i32 { unimplemented ! () } fn get_amount_varp (& self) -> i32 { unimplemented ! () } fn get_amount_shift (& self) -> i32 { unimplemented ! () } fn get_rune (& self , player_profile : & WebPlayerProfile) -> Option < Rune > { unimplemented ! () } fn get_amount (& self , player_profile : & WebPlayerProfile) -> i32 { unimplemented ! () } fn get_amount_for_rune (rune : & Rune , player_profile : & WebPlayerProfile) -> Option < i32 > { unimplemented ! () } }