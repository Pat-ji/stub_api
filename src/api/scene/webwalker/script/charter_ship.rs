static EMPTY_VEC_I8 : Vec < i8 > = vec ! [] ; static EMPTY_VEC_I32 : Vec < i32 > = vec ! [] ; use crate :: api :: domain :: entity :: Entity ; use crate :: api :: scene :: coords :: position :: Position ; use crate :: api :: scene :: npcs :: npcs_find_closest_by_name ; use crate :: api :: scene :: players :: players_get_local_player ; use crate :: api :: scene :: webwalker :: script :: barriers :: barriers_npc_interact ; use crate :: api :: scene :: webwalker :: web_player_profile :: WebPlayerProfile ; use crate :: api :: scene :: webwalker :: web_script :: WebScript ; use crate :: api :: ui :: dialogue :: { dialogue_complete_dialogue , dialogue_is_in_dialogue } ; use crate :: api :: ui :: tab :: quests :: Quest ; use crate :: api :: ui :: widgets :: { widgets_find_sub_widget , widgets_get_widget } ; use crate :: api :: util :: utils :: utils_sleep_conditional ; use rustc_hash :: FxHashMap ; use strum :: IntoEnumIterator ; use strum_macros :: EnumIter ; const CHARTER_SHIP_COUNT : usize = 16 ; # [derive (PartialEq , Copy , Clone , EnumIter)] enum CharterShip { Aldarin , Brimhaven , Catherby , CivitasIllaFortis , CorsairCove , LandsEnd , MosLeHarmless , MusaPoint , PortKhazard , PortPhasmatys , PortPiscarilius , PortSarim , PortTyras , Prifddinas , ShipYard , SunsetCoast , } impl CharterShip { fn get_index (& self) -> usize { unimplemented ! () } fn get_target_name (& self) -> & str { unimplemented ! () } fn get_position (& self) -> Position { unimplemented ! () } fn get_destination (& self) -> Position { unimplemented ! () } fn get_costs (& self) -> [i32 ; CHARTER_SHIP_COUNT] { unimplemented ! () } fn is_quest_completed_for_ship (p : & WebPlayerProfile , ship : & CharterShip) -> bool { unimplemented ! () } } pub (in crate :: api :: scene :: webwalker) fn charter_ship_load_all (result : & mut FxHashMap < (i32 , i32 , i32) , Vec < WebScript > >) { { } } fn charter_ship_load (from_charter_ship : CharterShip , result : & mut FxHashMap < (i32 , i32 , i32) , Vec < WebScript > >) { { } }