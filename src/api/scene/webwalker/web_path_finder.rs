static EMPTY_VEC_I8 : Vec < i8 > = vec ! [] ; static EMPTY_VEC_I32 : Vec < i32 > = vec ! [] ; use crate :: api :: scene :: coords :: local_path_finder :: DIRECTIONS ; use crate :: api :: scene :: coords :: position :: Position ; use crate :: api :: scene :: webwalker :: web_node :: { ConnectionDirection , PositionDirection , ScriptDirection , TeleportDirection , WebNode } ; use crate :: api :: scene :: webwalker :: web_region :: { web_region_id_to_world_base , WEB_REGION_SIZE } ; use crate :: api :: scene :: webwalker :: web_region :: { web_region_world_to_id , WebRegion } ; use crate :: api :: util :: cache :: cache_get_web_region ; use std :: collections :: HashMap ; use crate :: api :: scene :: collision_map :: CollisionMap ; use crate :: api :: scene :: coords :: area :: Area ; use crate :: api :: scene :: webwalker :: web_connection :: WebConnection ; use crate :: api :: scene :: webwalker :: web_player_profile :: WebPlayerProfile ; use crate :: api :: scene :: webwalker :: web_script :: { web_script_load_all , WebScript } ; use crate :: api :: scene :: webwalker :: web_teleport :: { web_teleport_get_all , WebTeleport } ; use crate :: api :: web_walking :: WebWalkingArgs ; use rustc_hash :: { FxBuildHasher , FxHashMap } ; use std :: cmp :: { max , min , Ordering , Reverse } ; use std :: collections :: BinaryHeap ; const WEB_PATH_COORD_TYPE_CONNECTION : u32 = 0 ; const WEB_PATH_COORD_TYPE_TELEPORT : u32 = 1 ; const WEB_PATH_COORD_TYPE_SCRIPT : u32 = 2 ; const WEB_PATH_MAX_REGIONS : usize = 128 ; pub (crate) struct WebPathArgs { blocked_areas : Option < Vec < Area > > , use_teleports : bool , use_charter_ships : bool , use_fairy_rings : bool , use_gliders : bool , use_spirit_trees : bool } impl Default for WebPathArgs { fn default () -> Self { unimplemented ! () } } impl WebPathArgs { pub (crate) fn new_from_walking_args (args : & WebWalkingArgs) -> Self { unimplemented ! () } pub (crate) fn get_use_teleports (& self) -> bool { unimplemented ! () } pub (crate) fn get_use_charter_ships (& self) -> bool { unimplemented ! () } pub (crate) fn get_use_fairy_rings (& self) -> bool { unimplemented ! () } pub (crate) fn get_use_gliders (& self) -> bool { unimplemented ! () } pub (crate) fn get_use_spirit_trees (& self) -> bool { unimplemented ! () } } pub fn web_path_finder_find_position_to_position (start : & Position , end : & Position , args : & WebWalkingArgs) -> Option < Vec < Position > > { None } pub fn web_path_finder_find_position_to_area (start : & Position , area : & Area , args : & WebWalkingArgs) -> Option < Vec < Position > > { None } pub (crate) fn web_path_finder_find_path_position_to_position (start : & Position , end : & Position , args : & WebWalkingArgs) -> Option < Vec < WebNode > > { None } pub (crate) fn web_path_finder_find_path_position_to_area (start : & Position , area : & Area , args : & WebWalkingArgs) -> Option < Vec < WebNode > > { None } pub (crate) fn web_path_finder_find_path < F > (src_x : i32 , src_y : i32 , src_plane : i32 , dst_x : i32 , dst_y : i32 , dst_plane : i32 , reached_condition : F , args : & WebPathArgs) -> Option < Vec < WebNode > > { None } # [derive (Debug , Clone , Copy , PartialEq , Eq)] struct TileNode { cost : i32 , f_score : i32 , x : i32 , y : i32 , plane : i32 , via : u32 , clipping : i32 , flags : u8 } impl TileNode { fn new (x : i32 , y : i32 , plane : i32 , clipping : i32) -> Self { unimplemented ! () } fn is_open (& self) -> bool { unimplemented ! () } fn set_open (& mut self , val : bool) { { } } fn is_closed (& self) -> bool { unimplemented ! () } fn set_closed (& mut self , val : bool) { { } } } impl Ord for TileNode { fn cmp (& self , other : & Self) -> Ordering { unimplemented ! () } } impl PartialOrd for TileNode { fn partial_cmp (& self , other : & Self) -> Option < Ordering > { unimplemented ! () } } struct FinderWebRegion { base_x : i32 , base_y : i32 , region : Option < WebRegion > , nodes : Box < [[TileNode ; WEB_REGION_SIZE] ; WEB_REGION_SIZE] > , } impl FinderWebRegion { fn new (region : WebRegion , args : & WebPathArgs) -> Self { unimplemented ! () } fn new_blocked (region_id : i32) -> Self { unimplemented ! () } fn get_connection (& self , from : & Position , target : & Position) -> Option < WebConnection > { unimplemented ! () } fn get_connection_targets_from (& self , world_x : i32 , world_y : i32) -> impl Iterator < Item = (i32 , i32 , i32) > { std :: iter :: empty () } fn get_node (& mut self , world_x : i32 , world_y : i32) -> & mut TileNode { unimplemented ! () } } fn pack_via (var1 : u32 , var2 : u32 , var3 : u32 , coord_type : u32) -> u32 { unimplemented ! () } fn unpack_via (via : u32) -> (u32 , u32 , u32 , u32) { unimplemented ! () } fn get_or_insert_region < 'a > (regions : & 'a mut FxHashMap < i32 , FinderWebRegion > , x : i32 , y : i32 , plane : i32 , args : & WebPathArgs) -> & 'a mut FinderWebRegion { unimplemented ! () } fn get_or_insert_node < 'a > (regions : & 'a mut FxHashMap < i32 , FinderWebRegion > , x : i32 , y : i32 , plane : i32 , args : & WebPathArgs) -> & 'a mut TileNode { unimplemented ! () } fn calc_heuristic (from_x : i32 , from_y : i32 , from_plane : i32 , target_x : i32 , target_y : i32 , target_plane : i32) -> i32 { unimplemented ! () }