static EMPTY_VEC_I8 : Vec < i8 > = vec ! [] ; static EMPTY_VEC_I32 : Vec < i32 > = vec ! [] ; use crate :: api :: camera :: camera_move_to_entity ; use crate :: api :: display :: display_get_world_screen_area ; use crate :: api :: domain :: graphics_object :: RSGraphicsObject ; use crate :: api :: domain :: ground_item :: RSGroundItem ; use crate :: api :: domain :: model :: Model ; use crate :: api :: domain :: npc :: RSNpc ; use crate :: api :: domain :: object :: Object ; use crate :: api :: domain :: player :: RSPlayer ; use crate :: api :: domain :: projectile :: RSProjectile ; use crate :: api :: domain :: world_view :: RSWorldView ; use crate :: api :: input :: mouse :: { mouse_click , mouse_get_position , mouse_move } ; use crate :: api :: scene :: coords :: position :: Position ; use crate :: api :: scene :: interactable :: { InteractArgs , Interactable } ; use crate :: api :: scene :: map :: map_can_reach_local_position ; use crate :: api :: scene :: players :: players_get_local_player ; use crate :: api :: ui :: menu :: { menu_contains_any_action , menu_interact } ; use crate :: api :: ui :: minimap :: minimap_click_position ; use crate :: api :: util :: performance :: performance_use_models ; use crate :: api :: util :: projection :: bounding_box :: { bounding_box_calculate_bounding_box , bounding_box_calculate_bounding_box_wd , BoundingBox } ; use crate :: api :: util :: utils :: utils_sleep_conditional ; use eframe :: egui :: { Color32 , Painter } ; use strum_macros :: EnumIter ; use crate :: api :: walking :: { walking_traverse , WalkingArgs } ; const INTERACT_ATTEMPTS : i32 = 3 ; # [derive (Debug , PartialEq , EnumIter , Copy , Clone)] pub enum EntityType { Player , Npc , Object , GroundItem , Projectile , GraphicsObject } pub enum EntityImpl { Player (RSPlayer) , Npc (RSNpc) , Object (Box < dyn Object >) , GroundItem (RSGroundItem) , Projectile (RSProjectile) , GraphicsObject (RSGraphicsObject) } pub enum InteractableImpl { BoundingBox (BoundingBox) , Model (Model) } impl InteractableImpl { pub fn contains (& self , point : (i32 , i32)) -> bool { unimplemented ! () } pub fn get_central_point (& self) -> (i32 , i32) { unimplemented ! () } pub fn get_interaction_point (& self) -> (i32 , i32) { unimplemented ! () } pub fn is_visible (& self) -> bool { unimplemented ! () } pub fn render (& self , painter : & Painter , color : Color32) { { } } } pub trait Entity : { fn get_type (& self) -> EntityType ; fn get_x (& self) -> i32 ; fn get_y (& self) -> i32 ; fn get_local_x (& self) -> i32 ; fn get_local_y (& self) -> i32 ; fn get_size_x (& self) -> i32 ; fn get_size_y (& self) -> i32 ; fn get_grid_x (& self) -> i32 ; fn get_grid_y (& self) -> i32 ; fn get_height (& self) -> i32 ; fn get_world_view (& self) -> & RSWorldView ; fn get_actions (& self) -> Vec < String > ; fn exists (& self) -> bool ; fn get_plane (& self) -> i32 { unimplemented ! () } fn get_position (& self) -> Position { unimplemented ! () } fn has_action (& self , action : & str) -> bool { unimplemented ! () } fn has_any_action (& self , actions : & [& str]) -> bool { unimplemented ! () } fn get_bounding_box (& self) -> BoundingBox { unimplemented ! () } fn get_model (& self) -> Option < Model > { unimplemented ! () } fn get_interactable (& self) -> InteractableImpl { unimplemented ! () } fn is_visible (& self) -> bool { unimplemented ! () } fn get_menu_vars (& self) -> Option < (i32 , i32 , i32) > { unimplemented ! () } fn get_menu_option (& self) -> Option < String > { unimplemented ! () } fn is_reachable (& self) -> bool { unimplemented ! () } fn hover_args (& self , args : & InteractArgs) -> bool { unimplemented ! () } fn click_args (& self , args : & InteractArgs , left : bool) -> bool { unimplemented ! () } fn interact_args (& self , args : & InteractArgs , action : & str) -> bool { unimplemented ! () } fn interact_any_args (& self , args : & InteractArgs , actions : & [& str]) -> bool { unimplemented ! () } fn hover (& self) -> bool { unimplemented ! () } fn click (& self , left : bool) -> bool { unimplemented ! () } fn interact (& self , action : & str) -> bool { unimplemented ! () } fn interact_any (& self , actions : & [& str]) -> bool { unimplemented ! () } }