static EMPTY_VEC_I8 : Vec < i8 > = vec ! [] ; static EMPTY_VEC_I32 : Vec < i32 > = vec ! [] ; use crate :: api :: client :: { client_is_loading , client_is_logged_in } ; use crate :: api :: domain :: entity :: Entity ; use crate :: api :: domain :: world_view :: RSWorldView ; use crate :: api :: scene :: coords :: area :: Area ; use crate :: api :: scene :: coords :: position :: Position ; use crate :: api :: scene :: map :: { map_can_reach_local_position , map_can_reach_position , MAP_GET_SIZE } ; use crate :: api :: scene :: players :: players_get_local_player ; use crate :: api :: scene :: region :: region_get_local_collision_flags ; use crate :: api :: scene :: webwalker :: web_node :: WebNode ; use crate :: api :: scene :: webwalker :: web_path_finder :: { web_path_finder_find_path_position_to_area , web_path_finder_find_path_position_to_position } ; use crate :: api :: scene :: world_view :: world_view_get_world_view ; use crate :: api :: script :: script_state :: ScriptState ; use crate :: api :: ui :: minimap :: minimap_is_position_in_minimap_range ; use crate :: api :: util :: bot :: bot_get_script_state ; use crate :: api :: util :: utils :: utils_sleep ; use crate :: api :: walking :: { walking_get_run_energy , walking_is_run_enabled , walking_set_run } ; use log :: error ; pub fn web_walking_traverse (args : & WebWalkingArgs) -> bool { unimplemented ! () } # [derive (Debug)] pub struct WebWalkingArgs { area : Option < Area > , destination : Option < Position > , break_condition : Option < fn () -> bool > , min_destination_threshold : i32 , min_minimap_threshold : i32 , min_run_energy : i32 , blocked_areas : Option < Vec < Area > > , use_teleports : bool , use_charter_ships : bool , use_fairy_rings : bool , use_gliders : bool , use_spirit_trees : bool } impl Default for WebWalkingArgs { fn default () -> Self { unimplemented ! () } } impl WebWalkingArgs { pub fn new_with_area (area : & Area) -> Self { unimplemented ! () } pub fn new_with_destination (destination : & Position) -> Self { unimplemented ! () } pub fn set_break_condition (& mut self , break_condition : fn () -> bool) -> & mut Self { unimplemented ! () } pub fn set_min_destination_threshold (& mut self , min_destination_threshold : i32) -> & mut Self { unimplemented ! () } pub fn set_min_minimap_threshold (& mut self , min_minimap_threshold : i32) -> & mut Self { unimplemented ! () } pub fn set_min_run_energy (& mut self , min_run_energy : i32) -> & mut Self { unimplemented ! () } pub fn set_blocked_areas (& mut self , blocked_areas : Vec < Area >) -> & mut Self { unimplemented ! () } pub fn set_use_teleports (& mut self , use_teleports : bool) -> & mut Self { unimplemented ! () } pub (crate) fn set_use_charter_ships (& mut self , use_charter_ships : bool) -> & mut Self { unimplemented ! () } pub (crate) fn set_use_fairy_rings (& mut self , use_fairy_rings : bool) -> & mut Self { unimplemented ! () } pub (crate) fn set_use_gliders (& mut self , use_gliders : bool) -> & mut Self { unimplemented ! () } pub (crate) fn set_use_spirit_trees (& mut self , use_spirit_trees : bool) -> & mut Self { unimplemented ! () } pub fn get_break_condition (& self) -> & Option < fn () -> bool > { unimplemented ! () } pub fn get_min_destination_threshold (& self) -> i32 { unimplemented ! () } pub fn get_min_minimap_threshold (& self) -> i32 { unimplemented ! () } pub fn get_min_run_energy (& self) -> i32 { unimplemented ! () } pub fn get_blocked_areas (& self) -> & Option < Vec < Area > > { unimplemented ! () } pub fn get_use_teleports (& self) -> bool { unimplemented ! () } pub fn get_use_charter_ships (& self) -> bool { unimplemented ! () } pub fn get_use_fairy_rings (& self) -> bool { unimplemented ! () } pub fn get_use_gliders (& self) -> bool { unimplemented ! () } pub fn get_use_spirit_trees (& self) -> bool { unimplemented ! () } fn reached_destination (& self , player_position : & Position) -> bool { unimplemented ! () } }