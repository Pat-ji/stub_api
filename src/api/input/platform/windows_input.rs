static EMPTY_VEC_I8 : Vec < i8 > = vec ! [] ; static EMPTY_VEC_I32 : Vec < i32 > = vec ! [] ; # [cfg (target_os = "windows")] pub (crate) mod windows_input { use crate :: api :: client :: C_PROCESS_ID ; use crate :: api :: util :: random :: random_from_normal ; use crate :: api :: util :: utils :: utils_sleep ; use std :: borrow :: Cow ; use std :: ffi :: CStr ; use windows :: core :: BOOL ; use windows :: Win32 :: Foundation :: { HWND , LPARAM , RECT , WPARAM } ; use windows :: Win32 :: Graphics :: Gdi :: { CreateCompatibleBitmap , CreateCompatibleDC , DeleteDC , DeleteObject , GetDC , GetDIBits , ReleaseDC , SelectObject , BITMAPINFO , BITMAPINFOHEADER , BI_RGB , DIB_RGB_COLORS , HBITMAP , HDC , HGDIOBJ } ; use windows :: Win32 :: UI :: Input :: KeyboardAndMouse :: { EnableWindow , MapVirtualKeyA , SendInput , INPUT , INPUT_0 , INPUT_MOUSE , MAPVK_VK_TO_VSC , MOUSEEVENTF_ABSOLUTE , MOUSEEVENTF_LEFTDOWN , MOUSEEVENTF_LEFTUP , MOUSEEVENTF_MIDDLEDOWN , MOUSEEVENTF_MIDDLEUP , MOUSEEVENTF_MOVE , MOUSEEVENTF_RIGHTDOWN , MOUSEEVENTF_RIGHTUP , MOUSEEVENTF_WHEEL , MOUSEINPUT } ; use windows :: Win32 :: UI :: WindowsAndMessaging :: { EnumChildWindows , EnumWindows , GetClassNameA , GetClientRect , GetSystemMetrics , GetWindowRect , GetWindowTextA , GetWindowThreadProcessId , IsWindowVisible , PostMessageA , SendMessageA , PW_RENDERFULLCONTENT , SM_CXSCREEN , SM_CYSCREEN , WM_CHAR , WM_KEYDOWN , WM_KEYUP , WM_LBUTTONDOWN , WM_LBUTTONUP , WM_MBUTTONDOWN , WM_MBUTTONUP , WM_MOUSEMOVE , WM_MOUSEWHEEL , WM_RBUTTONDOWN , WM_RBUTTONUP } ; const INPUT_JAG_RENDER_VIEW_CLASS : & str = "JagRenderView" ; const INPUT_JAG_WINDOW_CLASS : & str = "JagWindow" ; const INPUT_WINDOW_TITLE : & str = "Old School RuneScape" ; const MOUSE_BTN_LEFT : usize = 0x00000001 ; const MOUSE_BTN_RIGHT : usize = 0x00000002 ; static mut JAG_WINDOW_HWND : Option < HWND > = None ; static mut JAG_RENDER_VIEW_HWND : Option < HWND > = None ; pub (crate) static mut INPUT_HARDWARE_INPUT : bool = false ; static mut INPUT_DISABLED : bool = false ; pub (crate) unsafe fn input_initialize () { let _ = EnumWindows (Some (enum_windows_callback) , LPARAM (0)) ; let _ = EnumChildWindows (JAG_WINDOW_HWND , Some (enum_child_proc) , LPARAM (0)) ; } # [link (name = "user32")] extern "system" { fn PrintWindow (hwnd : HWND , hdcBlt : HDC , nFlags : u32) -> i32 ; } unsafe extern "system" fn enum_child_proc (hwnd : HWND , lparam : LPARAM) -> BOOL { if hwnd . is_invalid () { return BOOL (1) ; } let mut class_name : [u8 ; 256] = [0u8 ; 256] ; let class_len : i32 = GetClassNameA (hwnd , & mut class_name) ; if class_len > 0 { let class_name : Cow < str > = CStr :: from_ptr (class_name . as_ptr () as * const i8) . to_string_lossy () ; if class_name == INPUT_JAG_RENDER_VIEW_CLASS { JAG_RENDER_VIEW_HWND = Some (hwnd) ; return BOOL (0) ; } } BOOL (1) } unsafe extern "system" fn enum_windows_callback (hwnd : HWND , lparam : LPARAM) -> BOOL { if IsWindowVisible (hwnd) . as_bool () { let mut class_name : [u8 ; 256] = [0 ; 256] ; let mut window_title : [u8 ; 256] = [0 ; 256] ; let mut process_id : u32 = 0 ; GetWindowThreadProcessId (hwnd , Some (& mut process_id)) ; GetClassNameA (hwnd , & mut class_name) ; GetWindowTextA (hwnd , & mut window_title) ; let class_name_str : Cow < str > = CStr :: from_ptr (class_name . as_ptr () as * const i8) . to_string_lossy () ; let window_title_str : Cow < str > = CStr :: from_ptr (window_title . as_ptr () as * const i8) . to_string_lossy () ; if class_name_str == INPUT_JAG_WINDOW_CLASS && window_title_str == INPUT_WINDOW_TITLE && process_id == C_PROCESS_ID { JAG_WINDOW_HWND = Some (hwnd) ; return BOOL (0) ; } } BOOL (1) } pub (crate) fn input_is_input_blocked () -> bool { unsafe { INPUT_DISABLED } } pub (crate) fn input_block_input (block : bool) { unsafe { if let Some (hwnd) = JAG_RENDER_VIEW_HWND { INPUT_DISABLED = block ; let _ = EnableWindow (hwnd , ! INPUT_DISABLED) ; } } } pub (crate) fn input_send_mouse_move (x : i32 , y : i32) { unsafe { if INPUT_HARDWARE_INPUT { if let Some (hwnd) = JAG_RENDER_VIEW_HWND { let mut rect : RECT = RECT :: default () ; if GetWindowRect (hwnd , & mut rect) . is_ok () { let input = INPUT { r#type : INPUT_MOUSE , Anonymous : INPUT_0 { mi : MOUSEINPUT { dx : (rect . left + x) * 65535 / GetSystemMetrics (SM_CXSCREEN) , dy : (rect . top + y) * 65535 / GetSystemMetrics (SM_CYSCREEN) , mouseData : 0 , dwFlags : MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE , time : 0 , dwExtraInfo : 0 , } } } ; SendInput (& [input] , size_of :: < INPUT > () as i32) ; } } } else { let lparam : isize = ((y << 16) | (x & 0xFFFF)) as isize ; PostMessageA (JAG_RENDER_VIEW_HWND , WM_MOUSEMOVE , WPARAM (0) , LPARAM (lparam)) ; } } } pub (crate) fn input_send_mouse_move_with_buttons (x : i32 , y : i32 , left : bool) { unsafe { if INPUT_HARDWARE_INPUT { input_send_mouse_move (x , y) ; } else { let wparam : usize = if left { MOUSE_BTN_LEFT } else { MOUSE_BTN_RIGHT } ; let lparam : isize = ((y << 16) | (x & 0xFFFF)) as isize ; PostMessageA (JAG_RENDER_VIEW_HWND , WM_MOUSEMOVE , WPARAM (wparam) , LPARAM (lparam)) ; } } } pub (crate) fn input_send_mouse_wheel (delta : i32 , x : i32 , y : i32) { unsafe { if INPUT_HARDWARE_INPUT { input_send_mouse_move (x , y) ; let input = INPUT { r#type : INPUT_MOUSE , Anonymous : INPUT_0 { mi : MOUSEINPUT { dx : 0 , dy : 0 , mouseData : delta as u32 , dwFlags : MOUSEEVENTF_WHEEL , time : 0 , dwExtraInfo : 0 , } } } ; SendInput (& [input] , size_of :: < INPUT > () as i32) ; } else { let wheel_delta : i32 = delta * 120 ; let wparam : usize = (wheel_delta << 16) as usize ; let lparam : isize = ((y << 16) | (x & 0xFFFF)) as isize ; if let Some (hwnd) = JAG_RENDER_VIEW_HWND { SendMessageA (hwnd , WM_MOUSEWHEEL , WPARAM (wparam) , LPARAM (lparam)) ; } } } } pub (crate) fn input_send_mouse_wheel_click (x : i32 , y : i32 , down : bool) { unsafe { if INPUT_HARDWARE_INPUT { input_send_mouse_move (x , y) ; let input = INPUT { r#type : INPUT_MOUSE , Anonymous : INPUT_0 { mi : MOUSEINPUT { dx : 0 , dy : 0 , mouseData : 0 , dwFlags : if down { MOUSEEVENTF_MIDDLEDOWN } else { MOUSEEVENTF_MIDDLEUP } , time : 0 , dwExtraInfo : 0 , } } } ; SendInput (& [input] , size_of :: < INPUT > () as i32) ; } else { let lparam : isize = ((y << 16) | (x & 0xFFFF)) as isize ; let msg : u32 = if down { WM_MBUTTONDOWN } else { WM_MBUTTONUP } ; if let Some (hwnd) = JAG_RENDER_VIEW_HWND { SendMessageA (hwnd , msg , WPARAM (0) , LPARAM (lparam)) ; } } } } pub (crate) fn input_send_mouse_button (x : i32 , y : i32 , left : bool , down : bool) { unsafe { if INPUT_HARDWARE_INPUT { if down { input_send_mouse_move (x , y) ; } let input : INPUT = if down { INPUT { r#type : INPUT_MOUSE , Anonymous : INPUT_0 { mi : MOUSEINPUT { dx : 0 , dy : 0 , mouseData : 0 , dwFlags : if left { MOUSEEVENTF_LEFTDOWN } else { MOUSEEVENTF_RIGHTDOWN } , time : 0 , dwExtraInfo : 0 , } } , } } else { INPUT { r#type : INPUT_MOUSE , Anonymous : INPUT_0 { mi : MOUSEINPUT { dx : 0 , dy : 0 , mouseData : 0 , dwFlags : if left { MOUSEEVENTF_LEFTUP } else { MOUSEEVENTF_RIGHTUP } , time : 0 , dwExtraInfo : 0 , } } , } } ; SendInput (& [input] , size_of :: < INPUT > () as i32) ; } else { let lparam : isize = ((y << 16) | (x & 0xFFFF)) as isize ; let (down_message , up_message , wparam) = if left { (WM_LBUTTONDOWN , WM_LBUTTONUP , MOUSE_BTN_LEFT) } else { (WM_RBUTTONDOWN , WM_RBUTTONUP , MOUSE_BTN_RIGHT) } ; if let Some (hwnd) = JAG_RENDER_VIEW_HWND { if down { SendMessageA (hwnd , down_message , WPARAM (wparam) , LPARAM (lparam)) ; } else { SendMessageA (hwnd , up_message , WPARAM (0) , LPARAM (lparam)) ; } } } } } pub (crate) fn input_send_mouse_click (x : i32 , y : i32 , left : bool) { unsafe { if INPUT_HARDWARE_INPUT { input_send_mouse_move (x , y) ; let inputs : & [INPUT ; 2] = & [INPUT { r#type : INPUT_MOUSE , Anonymous : INPUT_0 { mi : MOUSEINPUT { dx : 0 , dy : 0 , mouseData : 0 , dwFlags : if left { MOUSEEVENTF_LEFTDOWN } else { MOUSEEVENTF_RIGHTDOWN } , time : 0 , dwExtraInfo : 0 , } } , } , INPUT { r#type : INPUT_MOUSE , Anonymous : INPUT_0 { mi : MOUSEINPUT { dx : 0 , dy : 0 , mouseData : 0 , dwFlags : if left { MOUSEEVENTF_LEFTUP } else { MOUSEEVENTF_RIGHTUP } , time : 0 , dwExtraInfo : 0 , } } , }] ; SendInput (inputs , size_of :: < INPUT > () as i32) ; } else { let lparam : isize = ((y << 16) | (x & 0xFFFF)) as isize ; let (down_message , up_message , wparam) = if left { (WM_LBUTTONDOWN , WM_LBUTTONUP , MOUSE_BTN_LEFT) } else { (WM_RBUTTONDOWN , WM_RBUTTONUP , MOUSE_BTN_RIGHT) } ; if let Some (hwnd) = JAG_RENDER_VIEW_HWND { SendMessageA (hwnd , down_message , WPARAM (wparam) , LPARAM (lparam)) ; utils_sleep (random_from_normal (100 , 20)) ; SendMessageA (hwnd , up_message , WPARAM (wparam) , LPARAM (lparam)) ; } } } } pub (crate) fn input_send_key (key_code : u32 , down : bool) { unsafe { let code : u32 = if down { WM_KEYDOWN } else { WM_KEYUP } ; PostMessageA (JAG_RENDER_VIEW_HWND , code , WPARAM (key_code as usize) , LPARAM (0)) ; } } pub (crate) fn input_send_keypress (key_code : u32) { unsafe { PostMessageA (JAG_RENDER_VIEW_HWND , WM_KEYDOWN , WPARAM (key_code as usize) , LPARAM ((MapVirtualKeyA (key_code , MAPVK_VK_TO_VSC) << 16) as isize | 0x00000001)) ; utils_sleep (random_from_normal (80 , 20)) ; PostMessageA (JAG_RENDER_VIEW_HWND , WM_KEYUP , WPARAM (key_code as usize) , LPARAM ((MapVirtualKeyA (key_code , MAPVK_VK_TO_VSC) << 16) as isize | 0xC0000001)) ; } } pub (crate) fn input_send_keychar (key_char : u32) { unsafe { PostMessageA (JAG_RENDER_VIEW_HWND , WM_CHAR , WPARAM (key_char as usize) , LPARAM (MOUSE_BTN_LEFT as isize)) ; } } pub (crate) fn input_get_client_rect () -> Option < (i32 , i32) > { unsafe { if let Some (hwnd) = JAG_RENDER_VIEW_HWND { let mut rect = RECT { left : 0 , top : 0 , right : 0 , bottom : 0 } ; if GetClientRect (hwnd , & mut rect) . is_ok () { return Some ((rect . right - rect . left , rect . bottom - rect . top)) ; } } } None } pub (crate) fn input_capture_client () -> Option < (i32 , i32 , Vec < u8 >) > { unsafe { let hwnd : HWND = JAG_RENDER_VIEW_HWND ? ; let (width , height) = if let Some ((width , height)) = input_get_client_rect () { (width , height) } else { (- 1 , - 1) } ; if width == - 1 || height == - 1 { return None ; } let hdc_window : HDC = GetDC (Some (hwnd)) ; if hdc_window . is_invalid () { return None ; } let hdc : HDC = CreateCompatibleDC (Some (hdc_window)) ; if hdc . is_invalid () { ReleaseDC (Some (hwnd) , hdc_window) ; return None ; } let bitmap : HBITMAP = CreateCompatibleBitmap (hdc_window , width , height) ; if bitmap . is_invalid () { DeleteDC (hdc) ; ReleaseDC (Some (hwnd) , hdc_window) ; return None ; } let old_bitmap : HGDIOBJ = SelectObject (hdc , HGDIOBJ :: from (bitmap)) ; let success : bool = PrintWindow (hwnd , hdc , PW_RENDERFULLCONTENT) != 0 ; let mut bmi = BITMAPINFO { bmiHeader : BITMAPINFOHEADER { biSize : size_of :: < BITMAPINFOHEADER > () as u32 , biWidth : width , biHeight : - height , biPlanes : 1 , biBitCount : 32 , biCompression : BI_RGB . 0 , .. std :: mem :: zeroed () } , bmiColors : [std :: mem :: zeroed () ; 1] , } ; let buffer_size : usize = (width * height * 4) as usize ; let mut buffer : Vec < u8 > = Vec :: with_capacity (buffer_size) ; let result = if success { GetDIBits (hdc , bitmap , 0 , height as u32 , Some (buffer . as_mut_ptr () as * mut _) , & mut bmi , DIB_RGB_COLORS) != 0 } else { false } ; SelectObject (hdc , old_bitmap) ; DeleteObject (HGDIOBJ :: from (bitmap)) ; DeleteDC (hdc) ; ReleaseDC (Some (hwnd) , hdc_window) ; if result { buffer . set_len (buffer_size) ; for pixel in buffer . chunks_exact_mut (4) { pixel . swap (0 , 2) ; } Some ((width , height , buffer)) } else { None } } } }